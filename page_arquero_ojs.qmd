---
title: "Exemple avec chargement de la data"
subtitle: "Observable JavaScript avec WidgetHTML : tableau, graphe, carte, inline code"
toc: true
theme: lumen
format:
  html:
    page-layout: full
    code-fold: true 
    code-summary: "Afficher le code" 
    code-tools: true
execute: 
  warning: false
resources: "data/donnees_combined.csv"
---

<!-- astuce : taper dans la console la ligne ci-dessous puis flÃ¨che vers le haut pour la rappeler, Ã§a Ã©vite un terminal et Ã§a fait une seule action -->
<!-- rstudioapi::documentSave();system("node convert.js page_arquero_ojs.qmd") -->

> Un exemple pour voir si la page arrive bien Ã  charger un csv dans le rÃ©pertoire data/ et Ã  l'exploiter avec des librairies js.

## La doc arquero

[Introduction Ã  Arquero](https://observablehq.com/@uwdata/introducing-arquero?collection=@uwdata/arquero)\
[Un cookbook](https://observablehq.com/@uwdata/arquero-cookbook)\
[Illustration en image des verbes d'arquero](https://observablehq.com/@uwdata/an-illustrated-guide-to-arquero-verbs?collection=@uwdata/arquero)\
[Doc complÃ¨te](https://idl.uw.edu/arquero/api/)

## Chargement des librairies, du csv et tableau de donnÃ©e

Ici les donnÃ©es ont Ã©tÃ© prÃ©parÃ©es au "format long", c'est un format trÃ¨s pratique pour simplement faire des filtres par la suite et pouvoir reprÃ©senter des "sÃ©ries" de donnÃ©es.\
La donnÃ©e est complexe : elle comprend Ã  la queuleuleue les donnÃ©es des quartiers mais aussi les donnÃ©es des quartiers agrÃ©gÃ©es Ã  la commune, dÃ©partement, rÃ©gion.

```{ojs}
import { aq, op } from '@uwdata/arquero' // le dplyr ou pandas du javascript
```

```{ojs}
// la donnÃ©e sera un dataframe au format arquero, ce format est compatible directement avec la librairie plot intÃ©grÃ© de ojs (sinon il est nÃ©cessaire de retransformer la donnÃ©e en object javascript pour les autres librairies)
myData = aq.loadCSV("./data/donnees_combined.csv");
```

```{ojs}
Inputs.table(myData)
```

## Filtre pour sÃ©lectionner les indicateurs tranche d'Ã¢ge

Un simple filtre permet de sÃ©lectionner tous les indicateurs relatifs aux tranches d'Ã¢ge.

```{ojs}
myDataTrancheAge = myData
  .filter(d => op.includes(d.indicateur, '_ans'))
```

```{ojs}
// Afficher la donnÃ©e
Inputs.table(myDataTrancheAge)
```


Ensuite, OJS contient tous les `input` de base, voici un exemple avec un slider

```{ojs}
viewof myQuartier = Inputs.range([1, 342], {step: 1, label: "Choisir un quartier"})
```

On peut lier cet input Ã  un filtre. DÃ¨s que l'on change la valeur du input, cela recalcule tous les blocs de code qui contiennent `myQuartier`.

```{ojs}
// Pourquoi aq.escape ? pour pouvoir mettre une variable extÃ©rieur au dataframe, aq.escape permet d'Ã©crire du javascript vanilla Ã  l'intÃ©rieur des verbes d'arquero
myDataQuartier = myDataTrancheAge
  .filter(aq.escape(d => d.id== myQuartier && d.echelle == 'recoquartier'))
```

```{ojs}
// Afficher les donnÃ©es
Inputs.table(myDataQuartier)
```


Et pour avoir un graphe interactif, il suffit de prendre entrÃ©e la variable filtrÃ©e selon le input.

```{ojs}
Plot.plot({
  title: "Ceci est un test",
  subtitle:"sous titre",
  marginLeft: 45,
  color: {legend: true, scheme:"reds" },
  marks: [
    Plot.barX(
      myDataQuartier,
        { x: "valeur" , y : "id", fill: "indicateur"}
    )
  ]
})
```

## Exemple plus complet de texte, tableau et graphe

### PrÃ©paration des donnÃ©es pour le Inputs.select

Au prÃ©alable, on prÃ©pare des donnÃ©es sur mesure pour notre Input pour choisir un quartier et on formate Ã§a aux petits oignons : selection de colonnes, filtre, pivot.

```{ojs}

// la librairie arquero permet de chaÃ®ner les traitements comme en R ou Python
dataSelectQ = myData
                .select('id','indicateur','valeur')
                .filter(aq.escape(d => d.indicateur == 'commune' || d.indicateur == 'nom_iris'))
                .groupby('id')
                .pivot('indicateur', 'valeur')
```
                
```{ojs}
// Afficher la donnÃ©e
Inputs.table(dataSelectQ)
```

### DonnÃ©es quartier avec rÃ©fÃ©rent rÃ©gional, stackBar

```{ojs}
// Le menu dÃ©roulant
viewof Q = Inputs.select(dataSelectQ, {label: "Choisir un quartier", format: d => `nÂ° ${d.id}-${d.commune} (${d.nom_iris})` })
```

**Vous avez sÃ©lectionner le quartier ðŸ¢ nÂ° \${Q.id} situÃ© sur la commune de \${Q.commune} (IRIS : \${Q.nom_iris})**

::::: grid
::: {.g-col-sm-12 .g-col-md-7}
Les donnÃ©es Ã©tant au format long, il suffit de filtrer :

-   selon l'identifiant du quartier
-   selon la valeur de l'Ã©chelle gÃ©ographique (avec un ou qui s'Ã©crit \|\| en javascript)
-   selon les libellÃ©s des indicateurs que l'on veut reprÃ©senter

```{ojs}
// PrÃ©paration de la donnÃ©e avec arquero :
myDataGrapheStackBar = myData
                  .filter( aq.escape(d => (d.id== Q.id && d.echelle == 'recoquartier') || d.echelle == 'multi_recoquartiers_region'  ) )
                  .filter( d => op.includes(d.indicateur, '_ans') )
                  .select('echelle','indicateur','valeur')
```

```{ojs}
// Un tableau sur 2 colonnes en faisant un pivot Ã  la volÃ©e
Inputs.table(
  myDataGrapheStackBar.groupby('indicateur').pivot('echelle','valeur'), {
  header: {
    multi_recoquartiers_region: "Ensemble des RecoQ",
    recoquartier: `RecoQ nÂ° ${Q.id}`
  },
  align: {
    multi_recoquartiers_region: "center",
    recoquartier: "center"
  }
})
```
:::

::: {.g-col-sm-12 .g-col-md-5}
La librairie plot permet de crÃ©er la plupart des graphes. TrÃ¨s Ã©lÃ©gante dans sa conception, elle est un peu difficile Ã  prendre en main... mais une fois la logique comprise elle permet de faire des graphes sur mesure complÃ¨tement responsive design.

```{ojs}
// Des stack bar sÃ©rie               
Plot.plot({
  marginLeft: 45,
  marginBottom: 60,
  marginTop: 60,
  style: {fontSize: "25px"},
  color: {legend: true },
  marks: [
    Plot.barY(
      myDataGrapheStackBar,
        { x : "echelle" ,y: "valeur" , fill: "indicateur", offset: "normalize", tip: true}
    )
  ]
})
```
:::
:::::

### BoÃ®tes Ã  moustache + symboles

```{ojs}
// Un exemple de la vraie vie, pour faire ce graphe, les valeurs n'ont pas Ã©tÃ© comprises comme des nombres mais comme du texte, en javascript on utilise parseFloat pour convertir ce texte en nombre et cela s'intÃ¨gre bien dans un traitement arquero

myDataBoxPlot = myData
                  .filter( d => d.echelle == 'recoquartier')
                  .filter( d => op.includes(d.indicateur, '_ans') )
                  .derive({
                    valeurNumber: aq.escape(d => parseFloat(d.valeur))
                  })
                  .select('id','echelle','indicateur','valeurNumber')
```

```{ojs}
myDataBoxPlotQ = myDataBoxPlot.filter(aq.escape(d => d.id == Q.id))

//Inputs.table(myDataBoxPlotQ)
```

```{ojs}
Plot.plot({
  caption: "Les boÃ®tes Ã  moustache reprÃ©sentent la dispersion des valeurs de l'ensemble des quartiers par tranche d'Ã¢ge, les symboles reprÃ©sentent les valeurs du quartier sÃ©lectionnÃ©",
  y: {
    grid: true
  },
  color: {legend:true, style: {fontSize: "14px"}},
  symbol: {legend: true, style: {fontSize: "14px"}},
  style: {fontSize: "14px"},
  marginBottom: 40,
  marginTop: 20,
  marks: [
    // boÃ®te Ã  moustache en sÃ©rie pour rÃ©prÃ©senter l'ensemble des quartiers
    Plot.boxY(myDataBoxPlot, {x: "indicateur", y: "valeurNumber", fill:"indicateur"}),

    // et un symbole pour positionner le quartier sÃ©lectionnÃ©
    Plot.dot(myDataBoxPlotQ, {
      x: "indicateur", 
      y: "valeurNumber", 
      fill: "white", 
      stroke:"black", 
      r: 5, 
      symbol: "indicateur",
      // un canal permet de rajouter des informations sur mesure Ã  partir des donnÃ©es
      channels: {
        quartier: {
          value: "id",
          label: "Quartier nÂ°"
        },
      },
      tip: {
        format: {
          quartier: true,
          id:true,
          indicateur: true,
          y: (d) => `${d*100} %`,
          stroke: false
        }
      }
    })
  ]
})
```
